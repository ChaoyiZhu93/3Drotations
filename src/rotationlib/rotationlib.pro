; ###################################################################
; Copyright (c) 2013-2015, Marc De Graef/Carnegie Mellon University
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without modification, are
; permitted provided that the following conditions are met:
;
;     - Redistributions of source code must retain the above copyright notice, this list
;        of conditions and the following disclaimer.
;     - Redistributions in binary form must reproduce the above copyright notice, this
;        list of conditions and the following disclaimer in the documentation and/or
;        other materials provided with the distribution.
;     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names
;        of its contributors may be used to endorse or promote products derived from
;        this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
; USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; ###################################################################

;--------------------------------------------------------------------------
; Original Code: CTEMsoft2013:rotations.f90
;--------------------------------------------------------------------------
;
; MODULE: rotations
;
;> @author Marc De Graef, Carnegie Mellon University
;
;> @brief everything that has to do with rotations and conversions between rotations
;
;> @details This file relies a lot on the relations listed in the book "Orientations
;> and Rotations" by Adam Morawiec [Springer 2004].  I've tried to implement every
;> available representation for rotations in a way that makes it easy to convert
;> between any pair.  Needless to say, this needs extensive testing and debugging...
;>
;> Instead of converting all the time between representations, I've opted to
;> "waste" a little more memory and time and provide the option to precompute all the representations.
;> This way all representations are available via a single data structure.
;>
;> Obviously, the individual conversion routines also exist and can be called either in
;> single or in double precision (using a function interface for each call, so that only
;> one function name is used).  The conversion routines use the following format for their
;> call name:  ab2cd, where (ab and cd are two-characters strings selected from the following
;> possibilities: [the number in parenthesis lists the number of entries that need to be provided]
;>
;> eu : euler angle representation (3)
;> om : orientation matrix representation (3x3)
;> ax : axis angle representation (4)
;> ro : Rodrigues vector representation (3)
;> qu : unit quaternion representation (4)
;> ho : homochoric representation (3)
;> cu : cubochoric representation (3).
;>
;> hence, conversion from homochoric to euler angle is called as ho2eu(); the argument of
;> each routine must have the correct number of dimensions and entries.
;> All 42 conversion routines exist in both single and double precision.
;>
;> Some routines were modified in July 2014, to simplify the paths in case the direct conversion
;> routine does not exist.  Given the complexity of the cubochoric transformations, all routines
;> going to and from this representation will require at least one and sometimes two or three
;> intermediate representations.  cu2eu and qu2cu currently represent the longest computation
;> paths with three intermediate steps each.
;>
;> In August 2014, all routines were modified to account for active vs. passive rotations,
;> after some inconsistencies were discovered that could be traced back to that distinction.
;> The default is for a rotation to be passive, and only those transformation rules have been
;> implemented.  For active rotations, the user needs to explicitly take action in the calling
;> program.
;>
;> Testing: the program rtest.pro was generated by an IDL script, mkrtestd.pro, and contains all possible
;> pairwise and triplet transformations, using a series of input angle combinations; for now, these
;> are potentially problematic Euler combinations.
;>
;> The conventions of this module are:
;>
;> - all reference frames are right-handed and orthonormal (except for the Bravais frames)
;> - a rotation angle is positive for a counterclockwise rotation when viewing along the positive rotation axis towards the origin
;> - all rotations are interpreted in the passive way
;> - Euler angles follow the Bunge convention, with phi1 in [0,2pi], Phi in [0,pi], and phi2 in [0,2pi]
;> - rotation angles (in axis-angle derived representations) are limited to the range [0,pi]
;>
;> To make things easier for the user, this module provides a routine to create a rotation
;> representation starting from an axis, described by a unit axis vector, and a rotation angle.
;> This routine properly takes the sign of epsijk into account, and always produces a passive rotation.
;> The user must explicitly take action to interpret a rotation a being active.
;>
;> @date 08/04/13 MDG 1.0 original
;> @date 07/08/14 MDG 2.0 modifications to several routines (mostly simplifications)
;> @date 08/08/14 MDG 3.0 added active/passive handling (all routines passive)
;> @date 08/11/14 MDG 3.1 modified Rodrigues vector to 4 components (n and length) to accomodate Infinity
;> @date 08/18/14 MDG 3.2 added RotateVector, RotateTensor2 routines with active/passive switch
;> @date 08/20/14 MDG 3.3 completed extensive testing of epsijk<0 mode; all tests passed for the first time !
;> @date 08/21/14 MDG 3.4 minor correction in om2ax to get things to work for epsijk>0 mode; all tests passed!
;> @date 09/30/14 MDG 3.5 added routines to make rotation definitions easier
;> @date 09/30/14 MDG 3.6 added strict range checking routines for all representations (tested on 10/1/14)
;> @date 03/11/14 MDG 4.0 conversion to IDL, all routines in double precision (single precision versions not converted)
;> @date 03/12/15 MDG 4.1 minor corrections; identity Rodrigues representation is [0,0,epsijk,0] !!!
;--------------------------------------------------------------------------



;--------------------------------------------------------------------------
;
; FUNCTION: ax2cu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert axis angle to cubochoric
;
;> @param a axis angle
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ax2cu,a, _EXTRA = ex
  COMPILE_OPT HIDDEN

  res = ho2cu(ax2ho(a, _EXTRA = ex), _EXTRA = ex)

  RETURN,res
END ;function ax2cu;--------------------------------------------------------------------------
;
; FUNCTION: ax2eu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert axis angle to euler
;
;> @param a axis angle pair
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ax2eu, ax_ang, _EXTRA=ex
  COMPILE_OPT HIDDEN

  eu = qu2eu(ax2qu(ax_ang, _EXTRA=ex), _EXTRA=ex)

  RETURN, eu

END;--------------------------------------------------------------------------
;
; Function: ax2ho
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Axis angle pair to homochoric
;
;> @param a axis-angle pair
;
;> @date 08/04/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ax2ho, ax_ang, P=P
  COMPILE_OPT HIDDEN

  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(ax_ang)/4
  ho = DBLARR(3,n)
  eps = 1.d-12

  f = (0.75d) * (ax_ang[3,*] - SIN(ax_ang[3,*]))
  f ^= (1.d/3.d)

  ho = ax_ang[0:2,*] * REBIN(REFORM([f], 1, n), 3, n)

  RETURN, ho

END
;--------------------------------------------------------------------------
;
; Function: ax2om
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Axis angle pair to orientation matrix
;
;> @note verified 8/5/13.
;
;> @param a axis angle pair
;
;> @date 08/04/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ax2om, ax_ang, P=P, Degrees=degrees
  COMPILE_OPT HIDDEN

  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(ax_ang)/4

  omatrix = DBLARR(3,3,n)
  trnsps = [1,0,2]



  c = COS(ax_ang[3,*] )
  s = SIN(ax_ang[3,*] )

  c1 = 1.d - c

  omatrix[0,0,*] = c + c1 * ax_ang[0,*]^2
  omatrix[1,0,*] = c1 * ax_ang[0,*] * ax_ang[1,*] - s * ax_ang[2,*]
  omatrix[2,0,*] = c1 * ax_ang[0,*] * ax_ang[2,*] + s * ax_ang[1,*]
  omatrix[0,1,*] = c1 * ax_ang[0,*] * ax_ang[1,*] + s * ax_ang[2,*]
  omatrix[1,1,*] = c + c1 * ax_ang[1,*]^2
  omatrix[2,1,*] = c1 * ax_ang[1,*] * ax_ang[2,*] - s * ax_ang[0,*]
  omatrix[0,2,*] = c1 * ax_ang[0,*] * ax_ang[2,*] - s * ax_ang[1,*]
  omatrix[1,2,*] = c1 * ax_ang[1,*] * ax_ang[2,*] + s * ax_ang[0,*]
  omatrix[2,2,*] = c + c1 * ax_ang[2,*]^2


  IF pfac LT 0 THEN omatrix = TRANSPOSE(omatrix, trnsps[0:(n GT 1)+1])

  RETURN, omatrix


END
;--------------------------------------------------------------------------
;
; FUNCTION: ax2qu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert axis angle to quaternion
;
;> @param a axis angle pair
;
;> @date 08/12/13 MDG 1.0 original
;> @date 07/23/14 MDG 1.1 explicit transformation
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ax2qu, ax_ang, P = P
  COMPILE_OPT HIDDEN


  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(ax_ang)/4
  eps = 1d-12
  quat = DBLARR(4, n)

  w2 = REFORM([ax_ang[3,*] * 0.5d], 1, n)
  s2 = SIN(w2) / (SQRT(TOTAL(ax_ang[0:2,*]^2, 1))+eps) ; check axis magnitude at same time
  quat[0,*] = COS(w2)
  quat[1:3,*] = REBIN(s2, 3, n) * ax_ang[0:2,*]

  RETURN, quat

END
;--------------------------------------------------------------------------
;
; FUNCTION: ax2ro
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert axis angle to Rodrigues
;
;> @param a axis angle pair
;
;> @date 08/12/13 MDG 1.0 original
;> @date 07/06/14 MDG 2.0 simplified
;> @date 08/11/14 MDG 2.1 added infty handling
;> @date 03/11/15 MDG 3.0 IDL version
;> @date 04/28/15 DJR 3.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ax2ro,ax_ang, P=P
  COMPILE_OPT HIDDEN

  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(ax_ang)/4
  eps = 1.d-12
  ax_ang = DOUBLE(ax_ang)
  ro = ax_ang
  temp =  TAN((ro[3,*]<(!DPI-eps))*0.5d)
  wh = WHERE(temp GT 1.d11 ,count)
  IF count GT 0 THEN temp[wh] =  !VALUES.D_INFINITY
  ro[3,*] = temp
  RETURN, ro
END;--------------------------------------------------------------------------
;
; FUNCTION: cu2ax
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert cubochoric to axis angle
;
;> @param c cubochoric coordinates
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION cu2ax,c, _Extra = ex
  COMPILE_OPT HIDDEN
  res = ho2ax(cu2ho(c, _Extra = ex), _Extra = ex)

  RETURN,res
END ;function cu2ax;--------------------------------------------------------------------------
;
; FUNCTION: cu2eu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert cubochoric to euler angles
;
;> @param c cubochoric coordinates
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION cu2eu,c, _EXTRA = ex
  COMPILE_OPT HIDDEN
  res = ho2eu(cu2ho(c,  _EXTRA = ex),  _EXTRA = ex)

  RETURN,res
END ;function cu2eu;--------------------------------------------------------------------------
;
; FUNCTION: cu2ho
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert cubochoric to homochoric
;
;> @param c cubochoric coordinates
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;--------------------------------------------------------------------------
FUNCTION cu2ho,c, _EXTRA = ex
  COMPILE_OPT HIDDEN

  lambertprojections
  ; calling program must have initialized the Lambert parameters!!!!
  res = lambert3dcubetoball(c,ierr)

  RETURN,res
END ;function cu2ho;--------------------------------------------------------------------------
;
; FUNCTION: cu2om
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert cubochoric to orientation matrix
;
;> @param c cubochoric coordinates
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION cu2om,c, _Extra = ex
  COMPILE_OPT HIDDEN
  res = ho2om(cu2ho(c,_EXTRA = ex),  _EXTRA = ex)

  RETURN,res
END ;function cu2om;--------------------------------------------------------------------------
;
; FUNCTION: cu2qu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert cubochoric to quaternion
;
;> @param c cubochoric coordinates
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION cu2qu,c, _Extra = ex
  COMPILE_OPT HIDDEN
  res = ho2qu(cu2ho(c, _Extra = ex), _Extra = ex)

  RETURN,res
END ;function cu2qu;--------------------------------------------------------------------------
;
; FUNCTION: cu2ro
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert cubochoric to Rodrigues
;
;> @param c cubochoric coordinates
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION cu2ro,c, _Extra = ex
  COMPILE_OPT HIDDEN
  res = ho2ro(cu2ho(c, _Extra = ex), _Extra = ex)

  RETURN,res
END ;function cu2ro;--------------------------------------------------------------------------
;
; FUNCTION: eu2ax
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert euler to axis angle
;
;> @param e 3 euler angles
;
;> @date 08/12/13 MDG 1.0 original
;> @date 07/23/14 MDG 2.0 explicit implementation
;> @date 07/23/14 MDG 2.1 exception for zero rotation angle
;> @date 03/11/15 MDG 3.0 IDL version
;> @date 04/28/15 DJR 3.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION eu2ax, euler_ang, degrees = degrees, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  IF KEYWORD_SET(degrees) THEN deg = !DPI/180. ELSE deg = 1.0d
  n = N_ELEMENTS(euler_ang)/3

  eps = 1.e-12

  ax_ang = DBLARR(4, N)



  t = TAN(euler_ang[1,*]*deg/2.d)
  sig = ( (0.5d*deg)*(euler_ang[0,*] + euler_ang[2,*]) )
  delt = ((0.5d*deg)*(euler_ang[0,*] - euler_ang[2,*]))
  tau = ( SQRT(t*t + SIN(sig)^2) )
  test = (ABS(sig-!PI/2.0d) GT eps)
  alpha = DOUBLE(test)*(2.0d*ATAN(tau/(COS(sig)+eps))) + DOUBLE(test EQ 0)*!DPI


  temp = -pfac/(tau + eps)
  ax_ang[0,*] = temp * t * COS(delt)
  ax_ang[1,*] = temp * t*SIN(delt)
  ax_ang[2,*] = temp * SIN(sig)
  ax_ang[3,*] = alpha

  sign = [DOUBLE(alpha GE 0) - DOUBLE(alpha LT 0)]
  sign = REBIN(REFORM(sign, 1, n), 4, n)

  ax_ang *= sign
  ax_ang[2,*] += -pfac*(ax_ang[3,*] LT eps)
  ; final check to make sure the angle is less than Pi.  Some rounding errors can mess with this
  test = (ax_ang[3,*] LE !DPI)
  testax = REBIN(REFORM(test*2.0d - 1.0d, 1, n), 3, n)
  ax_ang[0:2, *] *= testax
  ax_ang[3,*] = DOUBLE(test)*ax_ang[3,*] + DOUBLE(test EQ 0)*(2*!DPI - ax_ang[3,*])

  RETURN, ax_ang

END;--------------------------------------------------------------------------
;
; FUNCTION: eu2cu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert euler angles to cubochoric
;
;> @param e euler angles
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION eu2cu,e, _EXTRA = ex
  COMPILE_OPT HIDDEN
  res = ho2cu(eu2ho(e, _EXTRA = ex), _EXTRA = ex)

  RETURN,res
END ;function eu2cu;--------------------------------------------------------------------------
;
; FUNCTION: eu2ho
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert euler to homochoric
;
;> @param e 3 euler angles
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION eu2ho, e, _EXTRA = ex
  COMPILE_OPT HIDDEN
  ho = ax2ho(eu2ax(e, _EXTRA=ex), _EXTRA=ex)

  RETURN, ho
END;--------------------------------------------------------------------------
;
; Function: eu2om
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Euler angles to orientation matrix (single precision) [Morawiec, page 28]
;
;> @param e 3 Euler angles in radians
;
;> @date 08/04/13 MDG 1.0 original
;> @data 07/23/14 MDG 1.1 verified
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION eu2om, euler_ang, degrees=degrees, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  IF KEYWORD_SET(degrees) THEN deg = !DPI/180. ELSE deg = 1.0d
  n = N_ELEMENTS(euler_ang)/3
  omatrix = DBLARR(3,3,n)


  c = COS(euler_ang[1,*]*deg)
  s = SIN(euler_ang[1,*]*deg)
  c1 = COS(euler_ang[0,*]*deg)
  s1 = SIN(euler_ang[0,*]*deg)
  c2 = COS(euler_ang[2,*]*deg)
  s2 = SIN(euler_ang[2,*]*deg)


  omatrix[0,0,*] = c1*c2 - s1*c*s2
  omatrix[1,0,*] = s1*c2 + c1*c*s2
  omatrix[2,0,*] = s*s2
  omatrix[0,1,*] = -c1*s2 - s1*c*c2
  omatrix[1,1,*] = -s1*s2 + c1*c*c2
  omatrix[2,1,*] = s*c2
  omatrix[0,2,*] = s1*s
  omatrix[1,2,*] = -c1*s
  omatrix[2,2,*] = c

  RETURN, omatrix


END

;--------------------------------------------------------------------------
;
; Function: eu2qu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Euler angles to quaternion [Morawiec, page 40]
;
;> @note verified 8/5/13
;
;> @param e 3 Euler angles in radians
;
;> @date 08/04/13 MDG 1.0 original
;> @date 08/07/14 MDG 1.1 verified
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION eu2qu, euler_ang, degrees = degrees, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  IF KEYWORD_SET(degrees) THEN deg = !DPI/180. ELSE deg = 1.0d
  n = N_ELEMENTS(euler_ang)/3

  sig  = (0.5d*deg)*(euler_ang[0,*] + euler_ang[2,*])
  delt = (0.5d*deg)*(euler_ang[0,*] - euler_ang[2,*])
  c = COS(deg*euler_ang[1,*]*0.5d)
  s = SIN(deg*euler_ang[1,*]*0.5d)

  quat = DBLARR(4, n)
  quat[0,*] = c * COS(sig)
  quat[1,*] = -pfac * s * COS(delt)
  quat[2,*] = -pfac * s * SIN(delt)
  quat[3,*] = -pfac * c * SIN(sig)

  sign = REBIN(DOUBLE(quat[0,*] GE 0) - DOUBLE(quat[0,*] LT 0), 4, n, /sam)
  quat *= sign

  RETURN, quat
END;--------------------------------------------------------------------------
;
; Function: eu2ro
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Euler angles to Rodrigues vector [Morawiec, page 40]
;
;> @param e 3 Euler angles in radians (single precision)
;
;> @date 08/04/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION eu2ro, euler_ang, _EXTRA = ex ; degrees=degrees, p=p
  COMPILE_OPT HIDDEN
  n = N_ELEMENTS(euler_ang)/3
  ax = eu2ax(euler_ang, _EXTRA=ex)
  ro = ax2ro(ax, _EXTRA=ex)+0.0d

  RETURN, ro

END;--------------------------------------------------------------------------
;
; Function: ho2ax
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Homochoric to axis angle pair
;
;> @param h homochoric coordinates
;
;
;> @date 08/04/13 MDG 1.0 original
;> @date 07/21/14 MDG 1.1 double precision fit coefficients
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ho2ax, ho, P=P
  COMPILE_OPT HIDDEN

  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(ho)/3
  ax_ang = DBLARR(4, n)
  eps = 1.d-12

  tfit =  [1.0000000000018852D0, -0.5000000002194847D0, $
    -0.024999992127593126D0, - 0.003928701544781374D0, $
    -0.0008152701535450438D0, - 0.0002009500426119712D0, $
    -0.00002397986776071756D0, - 0.00008202868926605841D0, $
    +0.00012448715042090092D0, - 0.0001749114214822577D0, $
    +0.0001703481934140054D0, - 0.00012062065004116828D0, $
    +0.000059719705868660826D0, - 0.00001980756723965647D0, $
    +0.000003953714684212874D0, - 0.00000036555001439719544D0 ]


  mag = (TOTAL(ho*ho, 1))
  hm = mag

  hn = ho/REBIN(REFORM([SQRT(mag)+eps], 1, n), 3, n)
  hn[2,*] += (mag LT eps)
  s = tfit[0] + tfit[1] * mag

  FOR i=2, 15 DO BEGIN
    hm *= mag
    s += tfit[i]*hm
  ENDFOR

  s = 2.* ACOS((s < 1.0d) > (-1.0d))
  s = REFORM(s, 1, n)
  ax = [hn, s]

  RETURN, ax



END
;--------------------------------------------------------------------------
;
; FUNCTION: ho2cu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert homochoric to cubochoric
;
;> @param h homochoric coordinates
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ho2cu,h, _EXTRA = ex
  lambertprojections
  COMPILE_OPT HIDDEN
  res = lambert3dballtocube(h,ierr)

  RETURN,res
END ;function ho2cu;--------------------------------------------------------------------------
;
; FUNCTION: ho2eu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert homochoric to euler
;
;> @param h homochoric coordinates
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION ho2eu, h, _EXTRA=ex
  COMPILE_OPT HIDDEN
  eu = ax2eu(ho2ax(h, _EXTRA=ex), _EXTRA=ex)

  RETURN, eu


END;--------------------------------------------------------------------------
;
; FUNCTION: ho2om
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert homochoric to orientation matrix
;
;> @param h homochoric coordinates
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ho2om, ho, _EXTRA=ex
  COMPILE_OPT HIDDEN
  omatrix = ax2om(ho2ax(ho, _EXTRA=ex), _EXTRA=ex)

  RETURN, omatrix


END;--------------------------------------------------------------------------
;
; FUNCTION: ho2qu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert homochoric to quaternion
;
;> @param h homochoric coordinates
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION ho2qu, ho, _EXTRA=ex
  COMPILE_OPT HIDDEN
  quat = ax2qu(ho2ax(ho, _EXTRA=ex), _EXTRA=ex)

  RETURN, quat


END;--------------------------------------------------------------------------
;
; FUNCTION: ho2ro
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert homochoric to Rodrigues
;
;> @param h homochoric coordinates
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION ho2ro, h, _EXTRA=ex
  COMPILE_OPT HIDDEN
  ro = ax2ro(ho2ax(h, _EXTRA=ex), _EXTRA=ex)

  RETURN, ro


END;--------------------------------------------------------------------------
;
; FUNCTION: om2ax
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert orientation matrix to axis angle
;
;> @details this assumes that the matrix represents a passive rotation.
;
;> @param om 3x3 orientation matrix
;
;> @date 8/12/13  MDG 1.0 original
;> @date 07/08/14 MDG 2.0 replaced by direct solution
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION om2ax, omatrix, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p

  RETURN, qu2ax(om2qu(omatrix, P=P), P=P)

  n = N_ELEMENTS(omatrix)/9
  eps = 1.d-12

  ax_ang = DBLARR(4, n)

  tr = (omatrix[0,0,*] + omatrix[1,1,*] + omatrix[2,2,*])
  t = flat(0.5d *  (tr-1.0d))
  t <= 1.0d
  t >= -1.d
  ax_ang[3,*] = ACOS(t)

  test = (1-ABS(t)) GT eps ;test against degenerate cases of 0* and 180* rotations
  wh = WHERE(test, complement = nwh, /null , count, ncomplement = ncount)

  IF count GT 0 THEN BEGIN ; non degenerate case

    ax_ang[2,wh] = pfac*(omatrix[0,1,wh]-omatrix[1,0,wh])
    ax_ang[1,wh] = pfac*(omatrix[2,0,wh]-omatrix[0,2,wh])
    ax_ang[0,wh] = pfac*(omatrix[1,2,wh]-omatrix[2,1,wh])

    norm = REFORM([SQRT(TOTAL(ax_ang[0:2, wh]^2, 1))], 1, count)
    ax_ang[0:2,wh] *= 1.d/(REBIN(norm, 3, count))

  ENDIF


  IF ncount GT 0 THEN BEGIN ; degenerate cases

    wh_neg = WHERE(t[nwh] LT 0, count_neg, complement=wh_pos, ncomplement=count_pos)

    IF count_pos GT 0 THEN BEGIN ; this is a 0 degree rotation, arbitarily assign [0,0,1] axis
      ax_ang[0,nwh[wh_pos]] = 0.0d
      ax_ang[1,nwh[wh_pos]] = 0.0d
      ax_ang[2,nwh[wh_pos]] = 1.0
    ENDIF

    IF count_neg GT 0 THEN BEGIN ; [180* rotation, find the axis]
      indx = nwh[wh_neg]
      d = DBLARR(3, count_neg)

      FOR i = 0, 2 DO d[i,*] = SQRT( (omatrix[i,i,indx ] + 1.) * 0.5d)

      srt = sort_nd(d, 1)
      srt_c = srt MOD 3

      d[srt[1,*]] = omatrix[srt_c[2,*], srt_c[1,*], indx]/(2.0*d[srt[2,*]])
      d[srt[0,*]] = omatrix[srt_c[2,*], srt_c[0,*], indx]/(2.0*d[srt[2,*]])

      ax_ang[0:2, indx] = -pfac*d

    ENDIF

  ENDIF

  RETURN, ax_ang
END;--------------------------------------------------------------------------
;
; FUNCTION: om2cu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert orientation matrix to cubochoric
;
;> @param o orientation matrix
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION om2cu,o, _EXTRA = ex
  COMPILE_OPT HIDDEN
  res = ho2cu(om2ho(o, _EXTRA = ex), _EXTRA = ex)

  RETURN,res
END ;function om2cu;--------------------------------------------------------------------------
;
; Function: om2eu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief orientation matrix to euler angles
;
;> @note verified 8/19/14 using Mathematica
;
;> @param o orientation matrix (single precision)
;
;> @date 08/04/13 MDG 1.0 original
;> @date 08/19/14 MDG 1.1 verification using Mathematica
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION om2eu, omatrix, P=P, degrees = degrees
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  IF KEYWORD_SET(degrees) THEN deg = !DPI/180. ELSE deg = 1.0d
  n = N_ELEMENTS(omatrix)/9
  eulers = DBLARR(3,n)
  eps = 1.d-12

  zeta = 1.0d/SQRT( 1.0d - (omatrix[2,2,*]^2 - eps) )
  test = (1.d - omatrix[2,2,*]) GT eps
  wh = WHERE(test, complement = nwh, /null , count, ncomplement = ncount)

  eulers[1,*] = ACOS(omatrix[2,2,*]<1.d)
  IF count GT 0 THEN $
    eulers[0,wh] = ATAN(omatrix[0,2,wh]*zeta, -1.d * omatrix[1,2,wh]*zeta )

  IF ncount GT 0 THEN $
    eulers[0,nwh] = ATAN(omatrix[1,0,nwh], omatrix[0,0,nwh])

  eulers[2,*] = ATAN(omatrix[2,0,*]*zeta, omatrix[2,1,*]*zeta) * (eulers[1,*] GT eps)

  eulers[[0,2], *] += 2.0d*!DPI
  eulers[[0,2], *] MOD= 2.0d*!DPI

  RETURN, eulers/deg

END

;--------------------------------------------------------------------------
;
; FUNCTION: om2ho
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert orientation matrix to homochoric
;
;> @param om 3x3 orientation matrix
;
;> @date 08/12/13 MDG 1.0 original
;> @date 07/08/14 MDG 2.0 simplification via ax (shorter path)
;> @date 03/11/15 MDG 3.0 IDL version
;> @date 04/28/15 DJR 3.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION om2ho, om, _EXTRA=ex
  COMPILE_OPT HIDDEN
  ho = ax2ho(om2ax(om, _EXTRA=ex), _EXTRA=ex)

  RETURN, ho
END

;--------------------------------------------------------------------------
;
; FUNCTION: om2qu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert a 3x3 rotation matrix to a unit quaternion (see Morawiec, page 37)
;
;> @param x 3x3 matrix to be converted
;
;> @date 08/12/13 MDG 1.0 original
;> @date 08/18/14 MDG 2.0 new version
;> @date 03/11/15 MDG 3.0 IDL version
;> @date 04/28/15 DJR 3.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION om2qu, omatrix, P=P
  COMPILE_OPT HIDDEN

  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(omatrix)/9

  quat = DBLARR(4, n)

  q0 = 0.5d * SQRT((1.0d + omatrix[0,0,*] +  omatrix[1,1,*] +  omatrix[2,2,*]) > 0.0d)
  q0 = REFORM(q0, 1, n, /over)

  q1 = 0.5d * SQRT((1.0d + omatrix[0,0,*] -  omatrix[1,1,*] -  omatrix[2,2,*]) > 0.0d)
  q1 *= DOUBLE(omatrix[2,1,*] LT omatrix[1,2,*]) - DOUBLE(omatrix[2,1,*] GE omatrix[1,2,*])
  q1 *= pfac
  q1 = REFORM(q1, 1, n, /over)

  q2 = 0.5d * SQRT((1.0d - omatrix[0,0,*] +  omatrix[1,1,*] -  omatrix[2,2,*]) > 0.0d)
  q2 *=  DOUBLE(omatrix[0,2,*] LT omatrix[2,0,*]) - DOUBLE(omatrix[0,2,*] GE omatrix[2,0,*])
  q2 *= pfac
  q2 = REFORM(q2, 1, n, /over)

  q3 = 0.5d * SQRT((1.0d - omatrix[0,0,*] -  omatrix[1,1,*] +  omatrix[2,2,*]) > 0.0d)
  q3 *=  DOUBLE(omatrix[1,0,*] LT omatrix[0,1,*]) - DOUBLE(omatrix[1,0,*] GE omatrix[0,1,*])
  q3 *= pfac
  q3 = REFORM(q3, 1, n, /over)

  sign = DOUBLE(q0 GE 0.0d) - DOUBLE(q0 LT 0.0d)
  q0 *= sign
  q1 *= sign
  q2 *= sign
  q3 *= sign

  quat = [q0, q1, q2, q3]


  RETURN, quat

END
;--------------------------------------------------------------------------
;
; FUNCTION: om2ro
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert orientation matrix to Rodrigues
;
;> @param om 3x3 orientation matrix
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION om2ro, om, _EXTRA=ex
  COMPILE_OPT HIDDEN
  RETURN, qu2ro(om2qu(om, _EXTRA=ex), _EXTRA=ex)

END;--------------------------------------------------------------------------
;
; FUNCTION: qu2ax
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert quaternion to axis angle
;
;> @param q quaternion
;
;> @date 08/12/13 MDG 1.0 original
;> @date 07/23/14 MDG 2.0 explicit transformation
;> @date 03/11/15 MDG 3.0 IDL version
;> @date 04/28/15 DJR 3.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION qu2ax, quat, P = P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(quat)/4
  ax = DBLARR(4, n)
  eps = 1.d-12


  sign = DOUBLE(quat[0,*] GE 0) - DOUBLE(quat[0,*] LT 0)

  ang = 2.0d*ACOS(sign * quat[0,*])

  ax[3,*] = ang

  ax[0:2,*] = quat[1:3,*]*REBIN(REFORM([sign], 1, n), 3, n)
  mag = SQRT(TOTAL(quat[1:3,*]^2, 1))
  zeromag  = DOUBLE(mag EQ 0.0d)
  mag += zeromag
  ax[2,*] += pfac*zeromag

  ax[0:2,*] /=  REBIN(REFORM([mag], 1, n), 3, n)

  RETURN, ax

END



;--------------------------------------------------------------------------
;
; FUNCTION: qu2cu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert quaternion to cubochoric
;
;> @param q quaternion
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION qu2cu,q, _EXTRA = ex
  COMPILE_OPT HIDDEN
  res = ho2cu(qu2ho(q, _EXTRA = ex), _EXTRA = ex)

  RETURN,res
END ;function qu2cu;--------------------------------------------------------------------------
;
; Function: qu2eu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Quaternion to Euler angles [Morawiec page 40, with errata !!!! ]
;
;> @param q quaternion
;
;> @date 08/04/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION qu2eu, quat, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(quat)/4
  eu = DBLARR(3, n)

  eps = 1e-12

  q0 = quat[0,*] * pfac

  q03 = q0*q0 + quat[3,*]^2
  q12 = quat[1,*]^2 + quat[2,*]^2

  chi = SQRT(q03*q12)

  wh = WHERE(chi GT eps, count, complement=nwh, ncomplement = ncount)

  IF count GT 0 THEN BEGIN
    diff = ATAN(-1.d * quat[2,wh], -1.d * quat[1,wh])
    sum = ATAN(-1.d * quat[3,wh], q0[wh])
    eu[0,wh] = (diff + sum + 2.0d*!DPI) MOD (2.0d*!DPI)
    eu[2,wh] = (sum - diff + 2.0d*!DPI) MOD (2.0d*!DPI)

    eu[1,wh]= 2.0*ACOS(SQRT(q03[wh]))

  ENDIF

  IF ncount GT 0 THEN BEGIN

    wh12 = WHERE(q12[nwh] LT eps, count12, complement = wh03, ncomplement = count03)
    IF count12 GT 0 THEN BEGIN
      indx = nwh[wh12]
      eu[0,indx] = ATAN(-2.d * q0[indx]*quat[3,indx], q0[indx]^2 - quat[3,indx]^2)
      eu[1:2,indx] = 0.0d
    ENDIF

    IF count03 GT 0 THEN BEGIN
      indx = nwh[wh03]
      eu[0,indx] = ATAN(2.d * quat[1,indx]*quat[2,indx], quat[1,indx]^2 - quat[2,indx]^2)
      eu[1,indx] = !DPI
      eu[2,indx] = 0.0d

    ENDIF


  ENDIF

  eu[[0,2],*] += 2.0d*!PI
  eu[[0,2],*] MOD= 2.0d*!PI
  RETURN, eu

END;--------------------------------------------------------------------------
;
; FUNCTION: qu2ho
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert quaternion to homochoric
;
;> @param q quaternion
;
;> @date 08/12/13 MDG 1.0 original
;> @date 07/23/14 MDG 2.0 explicit transformation
;> @date 03/11/15 MDG 3.0 IDL version
;> @date 04/28/15 DJR 3.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION qu2ho, quat, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(quat)/4
  ho = DBLARR(3, n)
  eps = 1.d-12

  sign = DOUBLE(quat[0,*] GE 0) - DOUBLE(quat[0,*] LT 0) ; make sure the quaternion is in the Northern Hemisphere

  ang = 2.0d * ACOS(sign*quat[0,*])
  f = (0.75d *(ang - SIN(ang)))
  f ^= (1.d/3.d)

  vect = (quat[1:3,*] * REBIN(REFORM([sign], 1, n), 3, n))
  mag = f/(SQRT(TOTAL(vect*vect, 1)) + eps)

  ho = vect*REBIN(REFORM([mag], 1, n), 3, n)


  RETURN, ho


END;--------------------------------------------------------------------------
;
; FUNCTION: qu2om
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert a quaternion to a 3x3 matrix
;
;> @param q quaternion
;
;> @note verified 8/5/13
;
;> @date 06/03/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION qu2om, quat, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(quat)/4
  om = DBLARR(3,3, n)

  eps = 1.d-12

  q0 = quat[0,*] * pfac
  qbar = q0*q0 - (TOTAL(quat[1:3,*]^2, 1))

  om[0,0,*] = qbar + 2.0d * quat[1,*]^2
  om[1,0,*] = 2.0d * (quat[1,*] * quat[2,*] - q0 * quat[3,*])
  om[2,0,*] = 2.0d * (quat[1,*] * quat[3,*] + q0 * quat[2,*])
  om[0,1,*] = 2.0d * (quat[1,*] * quat[2,*] + q0 * quat[3,*])
  om[1,1,*] = qbar + 2.0d * quat[2,*]^2
  om[2,1,*] = 2.0d * (quat[2,*] * quat[3,*] - q0 * quat[1,*])
  om[0,2,*] = 2.0d * (quat[1,*] * quat[3,*] - q0 * quat[2,*])
  om[1,2,*] = 2.0d * (quat[2,*] * quat[3,*] + q0 * quat[1,*])
  om[2,2,*] = qbar + 2.0d * quat[3,*]^2

  RETURN, om

END;--------------------------------------------------------------------------
;
; FUNCTION: qu2ro
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert quaternion to Rodrigues
;
;> @param q quaternion
;
;> @date 08/12/13 MDG 1.0 original
;> @date 07/23/14 MDG 2.0 direct transformation
;> @date 08/11/14 MDG 2.1 added infty handling
;> @date 03/11/15 MDG 3.0 IDL version
;> @date 04/28/15 DJR 3.1 IDL array version
;--------------------------------------------------------------------------

FUNCTION qu2ro, quat, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(quat)/4
  ro = DBLARR(4, n)
  eps = 1.d-12


  sign = DOUBLE(quat[0,*] GE 0) - DOUBLE(quat[0,*] LT 0)

  ro[3,*] = TAN(ACOS(sign*quat[0,*]))
  ro[0:2,*] = quat[1:3,*]* REBIN(REFORM([sign],1, n), 3,n)

  mag = SQRT(TOTAL(quat[1:3,*]^2, 1))
  zeromag  = DOUBLE(mag LT eps)
  mag += zeromag
  ro[2,*] += pfac*zeromag

  ro[0:2,*] /=  REBIN(REFORM([mag], 1, n), 3, n)

  RETURN, ro


END
;--------------------------------------------------------------------------
;
; Function: ro2ax
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Rodrigues vector to axis angle pair
;
;> @param r Rodrigues vector
;
;> @date 08/04/13 MDG 1.0 original
;> @date0 8/11/14 MDG 1.1 added infty handling
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ro2ax, ro, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(ro)/4
  ax = ro

  ax[3,*] = 2.d*ATAN(ro[3,*])

  RETURN, ax

END;--------------------------------------------------------------------------
;
; FUNCTION: ro2cu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert Rodrigues to cubochoric
;
;> @param r Rodrigues
;
;> @note calling program MUST have initialized the Lambert parameters first!!!
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ro2cu,r, _EXTRA = ex
  COMPILE_OPT HIDDEN
  res = ho2cu(ro2ho(r, _EXTRA = ex), _EXTRA = ex)

  RETURN,res
END ;function ro2cu
;--------------------------------------------------------------------------
;
; Function: ro2eu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief Rodrigues vector to Euler angles
;
;> @param r Rodrigues vector
;
;> @date 08/04/13 MDG 1.0 original
;> @date 08/11/14 MDG 1.1 added infty handling
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ro2eu, r, _EXTRA = ex
  COMPILE_OPT HIDDEN
  eu  = qu2eu(ax2qu(ro2ax(r, _EXTRA=ex),_EXTRA=ex),_EXTRA=ex)
  RETURN, eu
END
;--------------------------------------------------------------------------
;
; FUNCTION: ro2ho
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert rodrigues to homochoric
;
;> @param r Rodrigues vector
;
;> @date 08/12/13 MDG 1.0 original
;> @date 07/24/14 MDG 2.0 explicit transformation
;> @date 08/11/14 MDG 3.0 added infty handling
;> @date 03/11/15 MDG 4.0 IDL version
;> @date 04/28/15 DJR 4.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ro2ho, ro, P=P
  COMPILE_OPT HIDDEN
  IF KEYWORD_SET(P) THEN pfac = DOUBLE(P GE 0) - DOUBLE(P LT 0) ELSE pfac = !ROTLIB.p
  n = N_ELEMENTS(ro)/4
  ho = DBLARR(3,n)
  eps = 1.d-12

  omega = 2.0d*ATAN(ro[3,*])
  f = (0.75d) * (omega - SIN(omega))
  f ^= (1.d/3.d)

  ho = ro[0:2,*] * REBIN(REFORM([f],1,n), 3, n)

  RETURN, ho

END;--------------------------------------------------------------------------
;
; FUNCTION: ro2om
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert rodrigues to orientation matrix
;
;> @param r Rodrigues vector
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ro2om, r, _EXTRA = ex
  COMPILE_OPT HIDDEN
  om  = ax2om(ro2ax(r, _EXTRA=ex),_EXTRA=ex)
  RETURN, om
END
;--------------------------------------------------------------------------
;
; FUNCTION: ro2qu
;
;> @author Marc De Graef, Carnegie Mellon University
;> @author David Rowenhorst, US Naval Research Laboratory
;
;> @brief convert rodrigues to quaternion
;
;> @param r Rodrigues vector
;
;> @date 08/12/13 MDG 1.0 original
;> @date 03/11/15 MDG 2.0 IDL version
;> @date 04/28/15 DJR 2.1 IDL array version
;--------------------------------------------------------------------------
FUNCTION ro2qu, ro, _EXTRA=ex
  COMPILE_OPT HIDDEN
  quat = ax2qu(ro2ax(ro, _EXTRA=ex), _EXTRA=ex)

  RETURN, quat

END

PRO rotationlib
  ;dummy proceedure
END